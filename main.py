import os
import time
import threading
import socket
import firebase_admin
from firebase_admin import credentials, db

hostMACAddress = '00:1f:e1:dd:08:3d'  # The MAC address of a Bluetooth adapter on the server.
port = 3  # 3 is an arbitrary choice. However, it must match the port used by the client.
data = None

s0 = None
s1 = None


def main():
    global data
    
    # Fetch the service account key JSON file contents
    cred = credentials.Certificate('smartwindow-da455-firebase-adminsdk-mscl2-c5ad694b44.json')
    # Initialize the app with a service account, granting admin privileges
    firebase_admin.initialize_app(cred, {
        'databaseURL': 'https://smartwindow-da455.firebaseio.com/'
    })
    
    ref = db.reference('/')
    
    if os.path.isfile('key.txt'):
        with open('key.txt', 'r') as f:
            data_ref = ref.child(f.read())
            data = data_ref.get()
    else:
        data = {
            's1': {
                'temperature': 0,
                'humidity': 0
            },
            's2': {
                'temperature': 0,
                'humidity': 0
            }
        }
        data_ref = ref.push(data)
        # Get the unique key generated by push()
        new_id = data_ref.key
        with open('key.txt', 'w') as f:
            f.write(new_id)
    
    x = threading.Thread(target=bluetooth)
    x.start()
    
    while True:
        # print(5)
        # data_ref.update(data)
        time.sleep(5)


def bluetooth():
    backlog = 2
    size = 1024
    s = socket.socket(socket.AF_BLUETOOTH, socket.SOCK_STREAM, socket.BTPROTO_RFCOMM)
    s.bind((hostMACAddress, port))
    s.listen(backlog)
    
    while True:
        client, address = s.accept()
        x = threading.Thread(target=bluetooth_client, args=(client, size))
        x.start()


def bluetooth_client(client: socket, size):
    global data, s0, s1
    
    if s0 is None:
        s0 = client
        sensor = 's0'
    elif s1 is None:
        s1 = client
        sensor = 's1'
    else:
        client.close()
        return
    print(sensor)
    
    try:
        while True:
            x = client.recv(size)
            print(x)
            if x:
                data[sensor] = x
    except:
        print('Closing socket')
        client.close()
